worker_processes auto;
error_log /dev/stderr warn;
pid /tmp/nginx.pid;

events {
    worker_connections 1024;
}

http {
    include /usr/local/openresty/nginx/conf/mime.types;
    default_type application/octet-stream;

    # Logging format with WAF fields
    log_format waf_format '$remote_addr - $remote_user [$time_local] '
                         '"$request" $status $body_bytes_sent '
                         '"$http_referer" "$http_user_agent" '
                         'ray=$waf_ray blocked=$waf_blocked';

    access_log /dev/stdout waf_format;

    # Rate limiting zone
    limit_req_zone $binary_remote_addr zone=api_limit:10m rate=200r/m;

    # Lua shared dict for WAF state
    lua_shared_dict waf_state 10m;

    # Load WAF module
    init_by_lua_block {
        waf = require("waf")
    }

    upstream backend {
        server nginx-proxy:8080;
        keepalive 32;
    }

    server {
        listen 80;
        server_name _;

        # Generate WAF headers
        set $waf_ray '';
        set $waf_blocked 'no';

        # Health check endpoint
        location = /health {
            access_log off;
            return 200 'OK';
            add_header Content-Type text/plain;
        }

        # Main WAF processing
        location / {
            # Rate limiting
            limit_req zone=api_limit burst=10 nodelay;
            limit_req_status 503;

            # WAF processing via Lua
            access_by_lua_block {
                local result = waf.check_request()
                if result.blocked then
                    ngx.var.waf_blocked = 'yes'
                    ngx.var.waf_ray = result.ray_id
                    ngx.status = result.status
                    ngx.header["Server"] = "EdgeShield"
                    ngx.header["X-WAF-Ray"] = result.ray_id
                    
                    if result.status == 503 then
                        ngx.header["Retry-After"] = "60"
                        ngx.say([[<!DOCTYPE html>
<html>
<head><title>Just a moment...</title></head>
<body>
<h1>Checking your browser before accessing.</h1>
<p>This process is automatic. Your browser will redirect shortly.</p>
<p>Ray ID: ]] .. result.ray_id .. [[</p>
<noscript>Please enable JavaScript.</noscript>
</body>
</html>]])
                    else
                        ngx.say([[<!DOCTYPE html>
<html>
<head><title>Access Denied</title></head>
<body>
<h1>403 Forbidden</h1>
<p>Request blocked by EdgeShield WAF.</p>
<p>Ray ID: ]] .. result.ray_id .. [[</p>
</body>
</html>]])
                    end
                    return ngx.exit(result.status)
                end
                ngx.var.waf_ray = result.ray_id
            }

            # Add WAF headers to response
            header_filter_by_lua_block {
                ngx.header["Server"] = "EdgeShield"
                ngx.header["X-WAF-Ray"] = ngx.var.waf_ray
            }

            # Proxy to backend
            proxy_pass http://backend;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Forwarded-Host $host;
            proxy_set_header Connection "";
            
            # Pass through all headers including Next-Action
            proxy_pass_request_headers on;
            
            # Increase buffer for large payloads
            proxy_buffer_size 256k;
            proxy_buffers 4 512k;
            proxy_busy_buffers_size 512k;
            client_max_body_size 10m;
        }

        # Custom 503 error page
        error_page 503 @ratelimit;
        location @ratelimit {
            default_type text/html;
            return 503 '<!DOCTYPE html>
<html>
<head><title>Rate Limited</title></head>
<body>
<h1>503 Service Temporarily Unavailable</h1>
<p>Too many requests. Please wait before retrying.</p>
</body>
</html>';
        }
    }
}
