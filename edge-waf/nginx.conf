worker_processes auto;
error_log /dev/stderr warn;
pid /tmp/nginx.pid;

# Optimized for 90+ concurrent CTF players
worker_rlimit_nofile 65535;

events {
    worker_connections 4096;
    use epoll;
    multi_accept on;
}

http {
    include /usr/local/openresty/nginx/conf/mime.types;
    default_type application/octet-stream;

    # Performance optimizations
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    keepalive_requests 10000;

    # ========== DoS / DDoS Protection ==========
    
    # Rate limiting zone - 100 req/s per IP (allows fuzzing, but prevents abuse)
    limit_req_zone $binary_remote_addr zone=api_limit:50m rate=100r/s;
    
    # Connection limiting - max 50 concurrent connections per IP
    limit_conn_zone $binary_remote_addr zone=conn_limit:50m;
    
    # IP Block zone - stores blocked IPs (60 second timeout)
    lua_shared_dict ip_blacklist 50m;
    lua_shared_dict rate_violations 10m;
    
    # Request body size limit (mitigates Ping of Death / large payload attacks)
    client_max_body_size 1m;
    client_body_buffer_size 128k;
    
    # Header size limits (mitigates header-based DoS)
    large_client_header_buffers 4 16k;
    client_header_buffer_size 4k;
    
    # Timeout protection (mitigates slowloris)
    client_body_timeout 10s;
    client_header_timeout 10s;
    send_timeout 10s;

    # Logging format with WAF fields
    log_format waf_format '$remote_addr - $remote_user [$time_local] '
                         '"$request" $status $body_bytes_sent '
                         '"$http_referer" "$http_user_agent" '
                         'ray=$waf_ray blocked=$waf_blocked';

    access_log /dev/stdout waf_format;

    # Lua shared dict for WAF state (increased for 90 users)
    lua_shared_dict waf_state 50m;

    # Load WAF and GeoCheck modules
    init_by_lua_block {
        waf = require("waf")
        geocheck = require("geocheck")
    }

    upstream backend {
        server nginx-proxy:8080;
        keepalive 128;
    }

    server {
        listen 80;
        server_name _;

        # Generate WAF headers
        set $waf_ray '';
        set $waf_blocked 'no';

        # Health check endpoint
        location = /health {
            access_log off;
            return 200 'OK';
            add_header Content-Type text/plain;
        }

        # Main WAF processing
        location / {
            # Connection limiting - max 50 concurrent per IP
            limit_conn conn_limit 50;
            limit_conn_status 429;
            
            # Rate limiting - 100 req/s per IP, burst 200 (allows ffuf -rate 100)
            limit_req zone=api_limit burst=200 nodelay;
            limit_req_status 429;

            # Check GeoIP + Blacklist + WAF
            access_by_lua_block {
                local ip = ngx.var.remote_addr
                local blacklist = ngx.shared.ip_blacklist
                
                -- GEO CHECK: Block non-Brazil IPs
                if not geocheck.is_brazil(ip) then
                    ngx.status = 403
                    ngx.header["Server"] = "EdgeShield"
                    ngx.header["X-Block-Reason"] = "Access restricted to Brazil only"
                    ngx.log(ngx.WARN, "GEO BLOCKED: " .. ip .. " (not from Brazil)")
                    ngx.say([[<!DOCTYPE html>
<html>
<head><title>Access Denied</title></head>
<body>
<h1>403 Forbidden</h1>
<p>Access to this CTF is restricted to Brazil only.</p>
<p>Este CTF Ã© restrito apenas para o Brasil.</p>
</body>
</html>]])
                    return ngx.exit(403)
                end
                
                -- Check if IP is in rate limit blacklist
                local blocked_until = blacklist:get(ip)
                if blocked_until and blocked_until > ngx.now() then
                    ngx.status = 429
                    ngx.header["Server"] = "EdgeShield"
                    ngx.header["Retry-After"] = math.ceil(blocked_until - ngx.now())
                    ngx.header["X-Block-Reason"] = "IP temporarily blocked due to rate limit violations"
                    ngx.say([[<!DOCTYPE html>
<html>
<head><title>Blocked</title></head>
<body>
<h1>429 Too Many Requests</h1>
<p>Your IP has been temporarily blocked due to excessive requests.</p>
<p>Please wait before retrying.</p>
</body>
</html>]])
                    return ngx.exit(429)
                end
                
                -- WAF processing
                local result = waf.check_request()
                if result.blocked then
                    ngx.var.waf_blocked = 'yes'
                    ngx.var.waf_ray = result.ray_id
                    ngx.status = result.status
                    ngx.header["Server"] = "EdgeShield"
                    ngx.header["X-WAF-Ray"] = result.ray_id
                    
                    if result.status == 503 then
                        ngx.header["Retry-After"] = "60"
                        ngx.say([[<!DOCTYPE html>
<html>
<head><title>Just a moment...</title></head>
<body>
<h1>Checking your browser before accessing.</h1>
<p>This process is automatic. Your browser will redirect shortly.</p>
<p>Ray ID: ]] .. result.ray_id .. [[</p>
<noscript>Please enable JavaScript.</noscript>
</body>
</html>]])
                    else
                        ngx.say([[<!DOCTYPE html>
<html>
<head><title>Access Denied</title></head>
<body>
<h1>403 Forbidden</h1>
<p>Request blocked by EdgeShield WAF.</p>
<p>Ray ID: ]] .. result.ray_id .. [[</p>
</body>
</html>]])
                    end
                    return ngx.exit(result.status)
                end
                ngx.var.waf_ray = result.ray_id
            }

            # Add WAF headers to response
            header_filter_by_lua_block {
                ngx.header["Server"] = "EdgeShield"
                ngx.header["X-WAF-Ray"] = ngx.var.waf_ray
            }

            # Proxy to backend
            proxy_pass http://backend;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Forwarded-Host $host;
            proxy_set_header Connection "";
            
            # Pass through all headers including Next-Action
            proxy_pass_request_headers on;
            
            # Increase buffer for large payloads
            proxy_buffer_size 256k;
            proxy_buffers 4 512k;
            proxy_busy_buffers_size 512k;
            client_max_body_size 10m;
        }

        # Rate limit / connection limit exceeded - block IP after violations
        error_page 429 @block_ip;
        location @block_ip {
            internal;
            content_by_lua_block {
                local ip = ngx.var.remote_addr
                local blacklist = ngx.shared.ip_blacklist
                local violations = ngx.shared.rate_violations
                
                -- Increment violation count for this IP
                local count, err = violations:incr(ip, 1, 0, 60)  -- 60 second window
                if not count then count = 1 end
                
                -- Block IP for 60 seconds after 3 violations
                if count >= 3 then
                    local block_duration = 60
                    blacklist:set(ip, ngx.now() + block_duration, block_duration)
                    ngx.log(ngx.WARN, "IP BLOCKED: " .. ip .. " after " .. count .. " violations")
                end
                
                ngx.status = 429
                ngx.header["Server"] = "EdgeShield"
                ngx.header["Retry-After"] = "60"
                ngx.header["Content-Type"] = "text/html"
                ngx.say([[<!DOCTYPE html>
<html>
<head><title>Rate Limited</title></head>
<body>
<h1>429 Too Many Requests</h1>
<p>You are sending too many requests. Slow down.</p>
<p>Violation count: ]] .. count .. [[/3</p>
</body>
</html>]])
            }
        }
        
        # Custom 503 error page
        error_page 503 @service_unavailable;
        location @service_unavailable {
            default_type text/html;
            return 503 '<!DOCTYPE html>
<html>
<head><title>Service Unavailable</title></head>
<body>
<h1>503 Service Temporarily Unavailable</h1>
<p>Please try again later.</p>
</body>
</html>';
        }
    }
}
